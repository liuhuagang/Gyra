# UE5_Lyra学习指南_013_泽_02_令牌验证流程

本文章仅为小刚-B站课堂-虚幻引擎视频课程Lyra-精讲的演讲手稿.
本套课程链接:[[UE5]虚幻引擎游戏案例Lyra精讲](https://www.bilibili.com/cheese/play/ss112001159)
前置课程链接:[[UE5]虚幻引擎UEC++从基础到进阶](https://www.bilibili.com/cheese/play/ss28043)

文章内容由小刚撰写,采用了以下多种方式:

1.口述转文字
2.AI重构
3.参考引擎源码
4.Lyra工程源码
5.结合社区论坛各位大佬的解析

- [UE5\_Lyra学习指南\_013\_泽\_02\_令牌验证流程](#ue5_lyra学习指南_013_泽_02_令牌验证流程)
  - [通讯流程](#通讯流程)
    - [服务器流程](#服务器流程)
      - [1.服务器调用](#1服务器调用)
      - [2.服务器生成](#2服务器生成)
      - [3. 服务器开启并发信息给客户端](#3-服务器开启并发信息给客户端)
    - [客户端流程](#客户端流程)
      - [1.客户端接受信息](#1客户端接受信息)
      - [2.客户端生成](#2客户端生成)
      - [3.客户端开启加密](#3客户端开启加密)
  - [总结](#总结)



## 通讯流程
本节内容不需要掌握.
有个概念就行.

启动流程客户端OnPreClientTravelToSession->携带令牌发送到服务器.

```txt
		// Setup encryption.
		// 
		// Future work: The beacon encryption handshake doesn't currently work as the encryption structure intends.
		// 
		// Intended flow: The encryption data is fetched using net delegate
		// Notes:
		//  The encryption data is fetched using net delegate
		// Sequence:
		//  1. Client sends encryption identifier.
		//  2. Host finds the key for the identifier and sends NMT_EncryptionAck, NMT_BeaconWelcome. - calls FNetDelegates::OnReceivedNetworkEncryptionToken
		//  3. Client finds key for identifier and enables encryption. - calls FNetDelegates::OnReceivedNetworkEncryptionAck.
		//
		// Current flow:
		// Notes:
		//  The encryption data is stored on the OnlineBeaconClient class
		//  The intended sequence can be forced by clearing the encryption data on the OnlineBeaconClient object after sending the initial hello packet.
		// Sequence:
		//  1. Client sets encryption key on the connection.
		//  2. Client sends encryption identifier.
		//  3. Host finds the key for the identifier and sends NMT_EncryptionAck, NMT_BeaconWelcome. - calls FNetDelegates::OnReceivedNetworkEncryptionToken
		//  4. Client uses stored key for identifier and enables encryption. - FNetDelegates::OnReceivedNetworkEncryptionAck is bypassed.

```

``` txt
// 设置加密。//
// 未来工作：当前，信标加密握手机制并未按照加密结构的预期方式运行。//
// 预期流程：通过网络委托获取加密数据
// 备注：
// 通过网络委托获取加密数据
// 步骤：
// 1. 客户端发送加密标识符。
// 2. 主机找到该标识符对应的密钥，并发送 NMT_EncryptionAck 和 NMT_BeaconWelcome。 - 调用 FNetDelegates:：OnReceivedNetworkEncryptionToken
// 3. 客户端找到该标识符的密钥并启用加密。 - 调用 FNetDelegates:：OnReceivedNetworkEncryptionAck。//
// 当前流程：
// 备注：
// 加密数据存储在 OnlineBeaconClient 类中
// 指定的序列可以通过在发送初始问候包后清除 OnlineBeaconClient 对象中的加密数据来强制执行。
// 序列：
// 1. 客户端在连接上设置加密密钥。
// 2. 客户端发送加密标识符。
// 3. 主机找到该标识符对应的密钥并发送 NMT_EncryptionAck 和 NMT_BeaconWelcome。 - 调用 FNetDelegates:：OnReceivedNetworkEncryptionToken
// 4. 客户端使用存储的标识符密钥并启用加密。 - FNetDelegates:：OnReceivedNetworkEncryptionAck 被跳过。

```

### 服务器流程
#### 1.服务器调用
 首先是在World.cpp的7100行 ,如果有绑定,就发起令牌校验加密流程.
``` cpp
void UWorld::NotifyControlMessage(UNetConnection* Connection, uint8 MessageType, class FInBunch& Bunch)
{
              //......

							if (FNetDelegates::OnReceivedNetworkEncryptionToken.IsBound())
							{
								FNetDelegates::OnReceivedNetworkEncryptionToken.Execute(EncryptionToken,
									FOnEncryptionKeyResponse::CreateUObject(Connection, &UNetConnection::SendChallengeControlMessage));
							}
							else
							{
								FString FailureMsg(TEXT("Encryption failure"));

								UE_LOG(LogNet, Warning, TEXT("%s: No delegate available to handle encryption token, disconnecting."),
										ToCStr(Connection->GetName()));

								Connection->SendCloseReason(ENetCloseResult::EncryptionFailure);
								FNetControlMessage<NMT_Failure>::Send(Connection, FailureMsg);
								Connection->FlushNet(true);
								Connection->Close(ENetCloseResult::EncryptionFailure);
							}


}
```
#### 2.服务器生成

``` cpp
void ULyraGameInstance::ReceivedNetworkEncryptionToken(const FString& EncryptionToken, const FOnEncryptionKeyResponse& Delegate)
{
    // ......  
    // 在视频中讲解
}

```

#### 3. 服务器开启并发信息给客户端

``` cpp
void UNetConnection::SendChallengeControlMessage(const FEncryptionKeyResponse& Response)
{
	if (GetConnectionState() != USOCK_Invalid && GetConnectionState() != USOCK_Closed && Driver)
	{
		if (Response.Response == EEncryptionResponse::Success)
		{
			EnableEncryptionServer(Response.EncryptionData);
			SendChallengeControlMessage();
		}
		else
		{
			FString ResponseStr(LexToString(Response.Response));
			UE_LOG(LogNet, Warning, TEXT("UWorld::SendChallengeControlMessage: encryption failure [%s] %s"), *ResponseStr, *Response.ErrorMsg);

			SendCloseReason(ENetCloseResult::EncryptionFailure);
			FNetControlMessage<NMT_Failure>::Send(this, ResponseStr);
			FlushNet(true);
			Close(ENetCloseResult::EncryptionFailure);
		}
	}
	else
	{
		UE_LOG(LogNet, Warning, TEXT("UNetConnection::SendChallengeControlMessage: connection in invalid state. %s"), *Describe());
	}
}
```

``` cpp

void UNetConnection::EnableEncryptionServer(const FEncryptionData& EncryptionData)
{
	if (GetConnectionState() != USOCK_Invalid && GetConnectionState() != USOCK_Closed && Driver)
	{
		SendClientEncryptionAck();
		EnableEncryption(EncryptionData);
	}
	else
	{
		UE_LOG(LogNet, Log, TEXT("UNetConnection::EnableEncryptionServer, connection in invalid state. %s"), *Describe());
	}
}

```

### 客户端流程

#### 1.客户端接受信息
在PendingNetGame.cpp的第426行

``` cpp
void UPendingNetGame::NotifyControlMessage(UNetConnection* Connection, uint8 MessageType, class FInBunch& Bunch)
{
      // ...

			if (FNetDelegates::OnReceivedNetworkEncryptionAck.IsBound())
			{
				TWeakObjectPtr<UNetConnection> WeakConnection = Connection;
				FNetDelegates::OnReceivedNetworkEncryptionAck.Execute(FOnEncryptionKeyResponse::CreateUObject(this, &UPendingNetGame::FinalizeEncryptedConnection, WeakConnection));
			}
			else
			{
				// This error will be resolved in TickWorldTravel()
				ConnectionError = TEXT("No encryption ack handler");

				// Force close the session
				UE_LOG(LogNet, Warning, TEXT("%s: No delegate available to handle encryption ack, disconnecting."), *Connection->GetName());
				Connection->Close();
			}

      // ...
  }

```

#### 2.客户端生成
``` cpp
void ULyraGameInstance::ReceivedNetworkEncryptionAck(const FOnEncryptionKeyResponse& Delegate)
{
    // ...
    // 在视频中讲解
}

```

#### 3.客户端开启加密

``` cpp
void UPendingNetGame::FinalizeEncryptedConnection(const FEncryptionKeyResponse& Response, TWeakObjectPtr<UNetConnection> WeakConnection)
{
	UNetConnection* Connection = WeakConnection.Get();
	if (Connection)
	{
		if (Connection->GetConnectionState() != USOCK_Invalid && Connection->GetConnectionState() != USOCK_Closed && Connection->Driver)
		{
			if (Response.Response == EEncryptionResponse::Success)
			{
				Connection->EnableEncryption(Response.EncryptionData);
			}
			else
			{
				// This error will be resolved in TickWorldTravel()
				FString ResponseStr(LexToString(Response.Response));
				UE_LOG(LogNet, Warning, TEXT("UPendingNetGame::FinalizeEncryptedConnection: encryption failure [%s] %s"), *ResponseStr, *Response.ErrorMsg);
				ConnectionError = TEXT("Encryption ack failure");
				Connection->Close();
			}
		}
		else
		{
			// This error will be resolved in TickWorldTravel()
			UE_LOG(LogNet, Warning, TEXT("UPendingNetGame::FinalizeEncryptedConnection: connection in invalid state. %s"), *Connection->Describe());
			ConnectionError = TEXT("Connection encryption state failure");
			Connection->Close();
		}
	}
	else
	{
		// This error will be resolved in TickWorldTravel()
		UE_LOG(LogNet, Warning, TEXT("UPendingNetGame::FinalizeEncryptedConnection: Connection is null."));
		ConnectionError = TEXT("Connection missing during encryption ack");
	}
}
```


``` cpp
void UNetConnection::EnableEncryption(const FEncryptionData& EncryptionData)
{
	if (Handler.IsValid())
	{
		UE_LOG(LogNet, Verbose, TEXT("UNetConnection::EnableEncryption, %s"), *Describe());

		TSharedPtr<FEncryptionComponent> EncryptionComponent = Handler->GetEncryptionComponent();
		if (EncryptionComponent.IsValid())
		{
			EncryptionComponent->SetEncryptionData(EncryptionData);
			EncryptionComponent->EnableEncryption();
		}
		else
		{
			UE_LOG(LogNet, Warning, TEXT("UNetConnection::EnableEncryption, encryption component not found!"));
		}
	}
}

```

## 总结
